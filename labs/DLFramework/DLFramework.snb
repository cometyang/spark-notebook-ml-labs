{
  "metadata" : {
    "id" : "ea6e0418-480d-4802-9895-1bb2505a26c7",
    "name" : "DLToyFramework",
    "user_save_timestamp" : "1970-01-01T03:00:00.000Z",
    "auto_save_timestamp" : "1970-01-01T03:00:00.000Z",
    "language_info" : {
      "name" : "scala",
      "file_extension" : "scala",
      "codemirror_mode" : "text/x-scala"
    },
    "trusted" : true,
    "sparkNotebook" : null,
    "customLocalRepo" : null,
    "customRepos" : null,
    "customDeps" : [ "org.bytedeco % javacpp % 1.3.2", "org.nd4j % nd4j-native-platform % 0.8.0", "org.nd4j %% nd4s % 0.8.0", "org.deeplearning4j % deeplearning4j-core % 0.8.0" ],
    "customImports" : null,
    "customArgs" : null,
    "customSparkConf" : {
      "spark.app.name" : "Notebook",
      "spark.master" : "local[*]",
      "spark.executor.memory" : "1G"
    },
    "customVars" : null
  },
  "cells" : [ {
    "metadata" : {
      "id" : "41AA1C0F55AF4BD18B68568DB6955E5D"
    },
    "cell_type" : "markdown",
    "source" : "# Neural Networks & Backpropagation with ND4J"
  }, {
    "metadata" : {
      "id" : "A3DC3AB7FE9B431AA612CF0C07BB877A"
    },
    "cell_type" : "markdown",
    "source" : "In this lab we're going to implement a small framework for training neural networks for classification tasks using [ND4J](http://nd4j.org/) numerical computing library ."
  }, {
    "metadata" : {
      "id" : "5148A96780CB44098761CD36FB987DD3"
    },
    "cell_type" : "markdown",
    "source" : "This lab is not intended to provide full explanation of underlying theory. Recommended materials: [deeplearningbook.org](http://www.deeplearningbook.org/), [Introduction to Deep Learning leacture slides](https://m2dsupsdlclass.github.io/lectures-labs/)."
  }, {
    "metadata" : {
      "id" : "EDCECD2182234444BA6E212ACF76B8FB"
    },
    "cell_type" : "markdown",
    "source" : "Our framework will support following neural network layers.\n\n<img src=\"http://telegra.ph/file/175a34024bc45651d0be6.png\" width=500>\n</img>\n\n - **Fully-connected layer (or dense layer)**. Neurons in a fully connected layer have full connections to all activations in the previous layer. Their activations can hence be computed with a matrix multiplication followed by a bias offset.*\n \n  $$\\mathrm{Dense} \\equiv f\\left(\\textbf{x}\\right)=\\textbf{W}\\textbf{x}+\\textbf{b},$$\n \n where $\\textbf{W}\\in\\mathbb{R}^{(k,n)}$ - weight matrix, $\\textbf{b}\\in\\mathbb{R}^k$ - bias offset.\n \n \n - **Sigmoid activation layer**. \n    $$\\mathrm{Sigmoid} \\equiv f\\left(\\textbf{x}\\right)=\\frac{1}{1+\\exp^{\\textbf{-x}}}$$\n    \n    \n - **[Dropout layer](https://www.cs.toronto.edu/~hinton/absps/JMLRdropout.pdf)**. It's introduced to prevent overfitting.\n It takes parameter $d$ which is equal to probability of individual neuron being \"dropped out\" during the *training stage* independently for each training example. The removed nodes are then reinserted into the network with their original weights. At *testing stage* we're using the full network with each neuron's output weighted by a factor of $1-d$, so the expected value of the output of any neuron is the same as in the training stages.\n \n    $$\\mathrm{Dropout_{train}} \\equiv f\\left(\\textbf{x}\\right)=\\textbf{m}\\odot\\textbf{x}$$\n    $$\\textbf{m} \\in \\left\\{0,1\\right\\}^{n}$$\n    $$p\\left(m_{i}=0\\right)=d$$\n    \n    $$\\mathrm{Dropout_{test}}\\equiv f\\left(\\textbf{x}\\right)=\\left(1-d\\right)\\textbf{x}$$\n    \n    \n - **Softmax classifier layer**. It's a generalization of binary Logistic Regression classifier to multiple classes. The Softmax classifier gives normalized class probabilities as its output.\n  \n   $$\\mathrm{Softmax}_{i} \\equiv p_{i}\\left(\\textbf{x}\\right)=\\frac{e^{x_{i}}}{\\sum_{j}{e^{x_{j}}}}$$\n   \n   We will use the Softmax classifier together with **cross-entropy loss** which is a generalization of binary log loss for multiple classes.\n   The cross-entropy between a “true” distribution $p$ and an estimated distribution $q$ is defined as:\n   \n   $$\\mathcal{L}=-\\sum_{i}{p_{i}\\log{q_{i}}}$$\n   \n   The Softmax classifier is hence minimizing the cross-entropy between the estimated class probabilities and the “true” distribution, where \"true\" distribution $\\textbf{p}=\\left[p_{1}...p_{i}...\\right]$ with only one element is equal to $1$ (true class) and all the other are equal to $0$. "
  }, {
    "metadata" : {
      "id" : "DA9AC02B70484CA6A0FDBDFEC3159353"
    },
    "cell_type" : "markdown",
    "source" : "## Install ND4J"
  }, {
    "metadata" : {
      "id" : "99CF86E3C3F44577AE1F8A61F449D194"
    },
    "cell_type" : "markdown",
    "source" : "### Prerequisites"
  }, {
    "metadata" : {
      "id" : "BDDAAA4E696A42298B100EF1EFAEE77A"
    },
    "cell_type" : "markdown",
    "source" : " - [JavaCPP](http://nd4j.org/getstarted#javacpp)\n - [BLAS (ATLAS, MKL, or OpenBLAS)](http://nd4j.org/getstarted#blas)"
  }, {
    "metadata" : {
      "id" : "7F87D6496B9D44A589F61E9CCFCCE7ED"
    },
    "cell_type" : "markdown",
    "source" : "### Configuring dependencies"
  }, {
    "metadata" : {
      "id" : "CB2A089DB6CE454A802DAC264B35B9C5"
    },
    "cell_type" : "markdown",
    "source" : "These will vary depending on whether you’re running on CPUs or GPUs.\nThe default backend for CPUs is `nd4j-native-platform`, and for CUDA it is `nd4j-cuda-7.5-platform`.\n\nAssuming the default backend for CPUs is used, `customDeps` section of Spark Notebook metadata (`Edit` -> `Edit Notebook Metadata`) should look like following:\n\n```\n \"customDeps\": [\n    \"org.bytedeco % javacpp % 1.3.2\",\n    \"org.nd4j % nd4j-native-platform % 0.8.0\",\n    \"org.nd4j %% nd4s % 0.8.0\",\n    \"org.deeplearning4j % deeplearning4j-core % 0.8.0\"\n  ]\n```"
  }, {
    "metadata" : {
      "id" : "BCD87D17A2DF4C9A8480F0D1583F8629"
    },
    "cell_type" : "markdown",
    "source" : "## Sigmoid & Softmax functions "
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "A4067CCA55FB4DC69A025D7126F21D6D"
    },
    "cell_type" : "code",
    "source" : "import org.nd4j.linalg.factory.Nd4j\nimport org.nd4j.linalg.api.ndarray.INDArray\nimport org.nd4j.linalg.ops.transforms.Transforms\n\nimport org.nd4j.linalg.cpu.nativecpu.rng.CpuNativeRandom",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "import org.nd4j.linalg.factory.Nd4j\nimport org.nd4j.linalg.api.ndarray.INDArray\nimport org.nd4j.linalg.ops.transforms.Transforms\nimport org.nd4j.linalg.cpu.nativecpu.rng.CpuNativeRandom\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 1,
      "time" : "Took: 2 seconds 268 milliseconds, at 2017-4-2 23:49"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "74E7992C196640C2831B9202DCA9DDF4"
    },
    "cell_type" : "code",
    "source" : "Nd4j.ones(2,3)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res3: org.nd4j.linalg.api.ndarray.INDArray = \n[[1.00, 1.00, 1.00],\n [1.00, 1.00, 1.00]]\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "[[1.00, 1.00, 1.00],\n [1.00, 1.00, 1.00]]"
      },
      "output_type" : "execute_result",
      "execution_count" : 2,
      "time" : "Took: 5 seconds 645 milliseconds, at 2017-4-2 23:49"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "85797E2F81AB4BD58042C4F90E36F2B8"
    },
    "cell_type" : "code",
    "source" : "val rngSEED = 181\nval RNG = new CpuNativeRandom(rngSEED)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "rngSEED: Int = 181\nRNG: org.nd4j.linalg.cpu.nativecpu.rng.CpuNativeRandom = org.nd4j.linalg.cpu.nativecpu.rng.CpuNativeRandom@2ffd784c\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 3,
      "time" : "Took: 1 second 565 milliseconds, at 2017-4-2 23:49"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "D14ECAF500734E6FB5AB8E3D5327D54A"
    },
    "cell_type" : "code",
    "source" : "import org.nd4s.Implicits._\n\ndef sigmoid(x: INDArray): INDArray = {\n  Transforms.pow(Transforms.exp(-x) + 1, -1)\n}\n \n\ndef sigmoidGrad(f: INDArray): INDArray = {\n  f * (-f + 1)\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "import org.nd4s.Implicits._\nsigmoid: (x: org.nd4j.linalg.api.ndarray.INDArray)org.nd4j.linalg.api.ndarray.INDArray\nsigmoidGrad: (f: org.nd4j.linalg.api.ndarray.INDArray)org.nd4j.linalg.api.ndarray.INDArray\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 4,
      "time" : "Took: 1 second 880 milliseconds, at 2017-4-2 23:50"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "E3AAA615A8494AA2ABEE01384040B244"
    },
    "cell_type" : "code",
    "source" : "/*\n * Compute the softmax function for each row of the input x.\n */\ndef softmax(x: INDArray): INDArray = {\n  val exps = Transforms.exp(x.addColumnVector(-x.max(1)))\n  exps.divColumnVector(exps.sum(1))\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "softmax: (x: org.nd4j.linalg.api.ndarray.INDArray)org.nd4j.linalg.api.ndarray.INDArray\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 5,
      "time" : "Took: 837 milliseconds, at 2017-4-2 23:50"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "B8C8D8BCDBA545BB959CE1B467CB2DE4"
    },
    "cell_type" : "code",
    "source" : "def sigmoidTest(): Unit = {\n  val x = Array(Array(1, 2), Array(-1, -2)).toNDArray\n  val f = sigmoid(x)\n  val g = sigmoidGrad(f)\n  val sigmoidVals = Array(Array(0.73105858, 0.88079708),\n                          Array(0.26894142, 0.11920292)).toNDArray\n  val gradVals = Array(Array(0.19661193, 0.10499359),\n                       Array(0.19661193, 0.10499359)).toNDArray\n  assert((f - Transforms.abs(sigmoidVals)).max(1) < 1e-6)\n  assert((g - Transforms.abs(gradVals)).max(1) < 1e-6)\n  println(\"sigmoid tests passed\")\n}\n\n\ndef softmaxTest(): Unit = {\n  val x = Array(Array(1001, 1002), \n                Array(3, 4)).toNDArray\n  val logits = softmax(x)\n  val expectedLogits = Array(Array(0.26894142, 0.73105858),\n                             Array(0.26894142, 0.73105858)).toNDArray\n  assert((logits - Transforms.abs(expectedLogits)).max(1) < 1e-6)\n  assert(\n    (softmax(Array(1, 1).toNDArray) - Transforms.abs(Array(0.5, 0.5).toNDArray)).max(1) < 1e-6\n  )\n  println(\"softmax tests passed\")\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "sigmoidTest: ()Unit\nsoftmaxTest: ()Unit\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 6,
      "time" : "Took: 1 second 149 milliseconds, at 2017-4-2 23:50"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "2AA4AF0D847C40C58B9EDFF54EFA5EC8"
    },
    "cell_type" : "code",
    "source" : "sigmoidTest\nsoftmaxTest",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "sigmoid tests passed\nsoftmax tests passed\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 7,
      "time" : "Took: 1 second 489 milliseconds, at 2017-4-2 23:50"
    } ]
  }, {
    "metadata" : {
      "id" : "D3B621B488064302A0E6D5C58222A408"
    },
    "cell_type" : "markdown",
    "source" : "## Network Layers"
  }, {
    "metadata" : {
      "id" : "50D28D3439C84453A671EF37619B9A57"
    },
    "cell_type" : "markdown",
    "source" : "Let's define `NetLayer` trait for building network layers. We need to provide two methods:\n - `forwardProp` for forward propagation of input through the neural network in order to generate the network's output.\n - `backProp` for delta backpropagation and weights update. \n   `backProp` takes the weight's output gradients with respect to layer's inputs. The weight's output gradient and input activation are multiplied to find the gradient of the weight. A ratio (gets tuned by `learningRate`) of the weight's gradient is subtracted from the weight."
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "8A710585A72E4F39A083A1C8ACE5F2CB"
    },
    "cell_type" : "code",
    "source" : "trait NetLayer {\n  def forwardProp(inputs: INDArray, isTrain: Boolean): INDArray\n  def backProp(outputsGrad: INDArray): INDArray\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "defined trait NetLayer\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 8,
      "time" : "Took: 920 milliseconds, at 2017-4-2 23:50"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "94BCEC29D1FF47F08E02B3016F5E0113"
    },
    "cell_type" : "code",
    "source" : "import org.nd4s.Implicits._\n\nclass Dense(inputDim: Int, outputDim: Int, val learningRate: Double) extends NetLayer {\n  private val W = Nd4j.rand(Array(inputDim, outputDim), -0.01, 0.01, RNG)\n  private val b = Nd4j.rand(Array(1, outputDim), -0.01, 0.01, RNG)\n  private var _inputs = Nd4j.zeros(1, inputDim)\n  \n  def forwardProp(inputs: INDArray, isTrain: Boolean): INDArray = {\n    _inputs = inputs\n    (inputs mmul W) addRowVector b\n  }\n  \n  def backProp(outputsGrad: INDArray): INDArray = {\n    val gradW = _inputs.T mmul outputsGrad\n    val gradb = outputsGrad.sum(0)\n    val prop = outputsGrad mmul W.T\n    W -= gradW * learningRate\n    b -= gradb * learningRate\n    prop\n  }\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "import org.nd4s.Implicits._\ndefined class Dense\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 9,
      "time" : "Took: 1 second 694 milliseconds, at 2017-4-2 23:50"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "C6928100FBFD4F9087EFB6550FDFCE0E"
    },
    "cell_type" : "code",
    "source" : "import org.nd4s.Implicits._\n\nclass SigmoidActivation extends NetLayer {\n  private var _outputs = Nd4j.zeros(1)\n  \n  def forwardProp(inputs: INDArray, isTrain: Boolean): INDArray = {\n    _outputs = sigmoid(inputs)\n    _outputs\n  }\n  \n  def backProp(outputsGrad: INDArray): INDArray = {\n    outputsGrad * sigmoidGrad(_outputs)\n  }\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "import org.nd4s.Implicits._\ndefined class SigmoidActivation\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 10,
      "time" : "Took: 2 seconds 18 milliseconds, at 2017-4-2 23:50"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "20930FAB2AA54B94BE12F94666C5EEA0"
    },
    "cell_type" : "code",
    "source" : "import org.nd4s.Implicits._\n\nclass Dropout(val dropRate: Double = 0.0) extends NetLayer {\n  var mask: INDArray = Nd4j.zeros(1)\n  def forwardProp(inputs: INDArray, isTrain: Boolean): INDArray = {\n    if (isTrain) {\n      mask = Nd4j.zeros(1, inputs.shape()(1))\n      Nd4j.choice(Array(0, 1).toNDArray, Array(dropRate, 1 - dropRate).toNDArray, mask)\n      inputs.mulRowVector(mask)\n    } else {\n      inputs * (1 - dropRate)\n    }    \n  }\n  \n  def backProp(outputsGrad: INDArray): INDArray = {\n    outputsGrad.mulRowVector(mask)\n  }\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "import org.nd4s.Implicits._\ndefined class Dropout\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 11,
      "time" : "Took: 1 second 921 milliseconds, at 2017-4-2 23:50"
    } ]
  }, {
    "metadata" : {
      "id" : "58FBF8A5DC08478C8843D6C1E91049FF"
    },
    "cell_type" : "markdown",
    "source" : "We assume that the **Softmax** is always the last layer of the network.\n\nAlso it can be shown that the gradient of cross-entropy loss of the outputs of softmax layer with respect to softmax layer's input has a simple form:\n\n $$\\frac{\\partial \\mathcal{L}}{\\partial x_{i}}=g_{i}-p_{i}$$\n \n So to start backpropagation stage let's take the `Softmax` output probabilities alongside with true labels as an input for `backProp` method of the `Softmax` layer.\n"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "F59BB35B716A451D820E82A0BA975BA3"
    },
    "cell_type" : "code",
    "source" : "import org.nd4s.Implicits._\n\nclass Softmax extends NetLayer {\n  def forwardProp(inputs: INDArray, isTrain: Boolean): INDArray = {\n    softmax(inputs)\n  }\n  \n  def backProp(outputsGrad: INDArray): INDArray = {\n    val predictions = outputsGrad(0, ->)\n    val labels = outputsGrad(1, ->)\n    predictions - labels\n  }\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "import org.nd4s.Implicits._\ndefined class Softmax\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 12,
      "time" : "Took: 1 second 875 milliseconds, at 2017-4-2 23:50"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "A871DC7E594B4BB388BD066A4D16A12A"
    },
    "cell_type" : "code",
    "source" : "def crossEntropy(predictions: INDArray, labels: INDArray): Double = {\n  val cost = - (Transforms.log(predictions) * labels).sumNumber.asInstanceOf[Double]\n  cost / labels.shape()(0)\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "crossEntropy: (predictions: org.nd4j.linalg.api.ndarray.INDArray, labels: org.nd4j.linalg.api.ndarray.INDArray)Double\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 13,
      "time" : "Took: 902 milliseconds, at 2017-4-2 23:50"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "AB7D21976ED946509245991859A7F766"
    },
    "cell_type" : "code",
    "source" : "def accuracy(predictions: INDArray, labels: INDArray): Double = {\n  val samplesNum = labels.shape()(0)\n  val matchesNum = (Nd4j.argMax(predictions, 1) eq Nd4j.argMax(labels, 1)).sumNumber.asInstanceOf[Double]\n  100.0 * matchesNum / samplesNum\n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "accuracy: (predictions: org.nd4j.linalg.api.ndarray.INDArray, labels: org.nd4j.linalg.api.ndarray.INDArray)Double\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 14,
      "time" : "Took: 1 second 115 milliseconds, at 2017-4-2 23:50"
    } ]
  }, {
    "metadata" : {
      "id" : "5985675AD417429F8BAED067FBF23F9C"
    },
    "cell_type" : "markdown",
    "source" : "## Neural Network"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "39AFAAFD2519433AAD40061184D5D2BF"
    },
    "cell_type" : "code",
    "source" : "import org.nd4j.linalg.dataset.api.iterator.DataSetIterator\nimport org.nd4j.linalg.dataset.DataSet",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "import org.nd4j.linalg.dataset.api.iterator.DataSetIterator\nimport org.nd4j.linalg.dataset.DataSet\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 15,
      "time" : "Took: 927 milliseconds, at 2017-4-2 23:50"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "7F4993AA238D48368F83FD50601B836E"
    },
    "cell_type" : "code",
    "source" : "case class Metric(epoch: Int, acc: Double, loss: Double)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "defined class Metric\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 16,
      "time" : "Took: 921 milliseconds, at 2017-4-2 23:50"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "B1F01220EC894EAD82FFA872B34771EF"
    },
    "cell_type" : "code",
    "source" : "import scala.collection.JavaConverters._\n\n\ncase class NeuralNet(layers: Vector[NetLayer] = Vector()) {\n  \n  def addLayer(layer: NetLayer): NeuralNet = {\n    this.copy(layers :+ layer)\n  }\n  \n  def fit(trainData: DataSetIterator, numEpochs: Int, validationData: DataSet): Seq[Metric] = {\n    val history = (1 to numEpochs).foldLeft(List[Metric]()){ (history, epoch) =>\n      trainData.reset()\n      trainData.asScala.foreach ( ds => trainBatch(ds.getFeatures, ds.getLabels) )\n      \n      // validate on validation Dataset\n      val prediction = this.predict(validationData.getFeatures)\n      val loss = crossEntropy(prediction, validationData.getLabels)\n      val acc = accuracy(prediction, validationData.getLabels)\n      \n      println(s\"Epoch: $epoch/$numEpochs - loss: $loss - acc: $acc\")\n\n      Metric(epoch, acc, loss) :: history\n    }\n    history.reverse\n  }\n  \n  def predict(X: INDArray): INDArray = {\n    layers.foldLeft(X){\n      (input, layer) => layer.forwardProp(input, isTrain=false)\n    }\n  }\n    \n  private def trainBatch(X: INDArray, Y: INDArray): Unit = {\n    val YPredict = layers.foldLeft(X){\n      (input, layer) => layer.forwardProp(input, isTrain=true)\n    }\n    val shape = Y.shape\n    layers.reverse.foldLeft(\n      Nd4j.vstack(YPredict, Y).reshape(2, shape(0), shape(1))\n    ){\n      (deriv, layer) => layer.backProp(deriv)\n    }\n  }  \n}",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "import scala.collection.JavaConverters._\ndefined class NeuralNet\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 17,
      "time" : "Took: 2 seconds 661 milliseconds, at 2017-4-2 23:50"
    } ]
  }, {
    "metadata" : {
      "id" : "D2392D6C4AE34622B923A3CADA688261"
    },
    "cell_type" : "markdown",
    "source" : "## MNIST"
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "ACE10B0E92964245B8FD82C1E99C27AF"
    },
    "cell_type" : "code",
    "source" : "import org.deeplearning4j.datasets.iterator.impl.MnistDataSetIterator",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "import org.deeplearning4j.datasets.iterator.impl.MnistDataSetIterator\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 18,
      "time" : "Took: 977 milliseconds, at 2017-4-2 23:50"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "0BBA2DB07555458E81F95AAF7A83CC8A"
    },
    "cell_type" : "code",
    "source" : "val learningRate = 0.01\nval batchSize = 128\n\nval mnistTrain = new MnistDataSetIterator(batchSize, true, rngSEED)\nval mnistTest = new MnistDataSetIterator(batchSize, false, rngSEED)\n\nval inputDim = mnistTest.next.getFeatures.shape()(1)\nval totalTestExamples = mnistTest.numExamples()",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "learningRate: Double = 0.01\nbatchSize: Int = 128\nmnistTrain: org.deeplearning4j.datasets.iterator.impl.MnistDataSetIterator = org.deeplearning4j.datasets.iterator.impl.MnistDataSetIterator@7ab58ec2\nmnistTest: org.deeplearning4j.datasets.iterator.impl.MnistDataSetIterator = org.deeplearning4j.datasets.iterator.impl.MnistDataSetIterator@3681f6e8\ninputDim: Int = 784\ntotalTestExamples: Int = 10000\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 19,
      "time" : "Took: 1 second 710 milliseconds, at 2017-4-2 23:50"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "CD9BBCF630D4409D8F3F45064D765264"
    },
    "cell_type" : "code",
    "source" : "val model = NeuralNet()\n            .addLayer(new Dense(inputDim=inputDim, outputDim=512, learningRate=learningRate))\n            .addLayer(new SigmoidActivation())\n            .addLayer(new Dropout(dropRate=0.3))\n            .addLayer(new Dense(512, 512, learningRate))\n            .addLayer(new SigmoidActivation())\n            .addLayer(new Dropout(0.3))\n            .addLayer(new Dense(512, 10, learningRate))\n            .addLayer(new Softmax())",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "model: NeuralNet = NeuralNet(Vector($iwC$$iwC$Dense@6e34cf41, $iwC$$iwC$SigmoidActivation@7b916832, $iwC$$iwC$Dropout@72dec70f, $iwC$$iwC$Dense@1322cf19, $iwC$$iwC$SigmoidActivation@5b2454fb, $iwC$$iwC$Dropout@2b846755, $iwC$$iwC$Dense@2f662b95, $iwC$$iwC$Softmax@2ab96367))\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 20,
      "time" : "Took: 989 milliseconds, at 2017-4-2 23:50"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "153C4951EE454D068DE1F8E03DF6EB5F"
    },
    "cell_type" : "code",
    "source" : "val history = model.fit(mnistTrain, 40, (new MnistDataSetIterator(totalTestExamples, false, rngSEED)).next)",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "Epoch: 1/40 - loss: 0.57162705078125 - acc: 81.94\nEpoch: 2/40 - loss: 0.348628173828125 - acc: 89.34\nEpoch: 3/40 - loss: 0.273960546875 - acc: 91.83\nEpoch: 4/40 - loss: 0.2305306396484375 - acc: 92.76\nEpoch: 5/40 - loss: 0.20194395751953126 - acc: 93.76\nEpoch: 6/40 - loss: 0.17214320068359376 - acc: 94.87\nEpoch: 7/40 - loss: 0.15777041015625 - acc: 95.29\nEpoch: 8/40 - loss: 0.1411923583984375 - acc: 95.75\nEpoch: 9/40 - loss: 0.1371442138671875 - acc: 95.65\nEpoch: 10/40 - loss: 0.1223932373046875 - acc: 96.2\nEpoch: 11/40 - loss: 0.11889525146484375 - acc: 96.35\nEpoch: 12/40 - loss: 0.11355523681640625 - acc: 96.5\nEpoch: 13/40 - loss: 0.10255557861328125 - acc: 96.63\nEpoch: 14/40 - loss: 0.10248739013671875 - acc: 96.67\nEpoch: 15/40 - loss: 0.10121082153320313 - acc: 96.76\nEpoch: 16/40 - loss: 0.09314661254882813 - acc: 97.05\nEpoch: 17/40 - loss: 0.0908234619140625 - acc: 97.09\nEpoch: 18/40 - loss: 0.08782809448242188 - acc: 97.21\nEpoch: 19/40 - loss: 0.084460498046875 - acc: 97.25\nEpoch: 20/40 - loss: 0.08508148803710938 - acc: 97.32\nEpoch: 21/40 - loss: 0.08242890625 - acc: 97.49\nEpoch: 22/40 - loss: 0.07931015014648438 - acc: 97.55\nEpoch: 23/40 - loss: 0.07825602416992188 - acc: 97.6\nEpoch: 24/40 - loss: 0.07847127685546874 - acc: 97.47\nEpoch: 25/40 - loss: 0.07547276611328126 - acc: 97.6\nEpoch: 26/40 - loss: 0.074110009765625 - acc: 97.64\nEpoch: 27/40 - loss: 0.07486264038085938 - acc: 97.69\nEpoch: 28/40 - loss: 0.07151276245117187 - acc: 97.73\nEpoch: 29/40 - loss: 0.07469411010742187 - acc: 97.76\nEpoch: 30/40 - loss: 0.06966272583007813 - acc: 97.88\nEpoch: 31/40 - loss: 0.066982666015625 - acc: 97.84\nEpoch: 32/40 - loss: 0.06796741333007812 - acc: 97.87\nEpoch: 33/40 - loss: 0.06789564208984375 - acc: 97.95\nEpoch: 34/40 - loss: 0.065538916015625 - acc: 98.03\nEpoch: 35/40 - loss: 0.066549365234375 - acc: 97.88\nEpoch: 36/40 - loss: 0.06736263427734375 - acc: 97.83\nEpoch: 37/40 - loss: 0.0646685302734375 - acc: 97.98\nEpoch: 38/40 - loss: 0.0628564208984375 - acc: 97.97\nEpoch: 39/40 - loss: 0.0657330322265625 - acc: 98.0\nEpoch: 40/40 - loss: 0.063365771484375 - acc: 97.98\nhistory: Seq[Metric] = List(Metric(1,81.94,0.57162705078125), Metric(2,89.34,0.348628173828125), Metric(3,91.83,0.273960546875), Metric(4,92.76,0.2305306396484375), Metric(5,93.76,0.20194395751953126), Metric(6,94.87,0.17214320068359376), Metric(7,95.29,0.15777041015625), Metric(8,95.75,0.1411923583984375), Metric(9,95.65,0.1371442138671875), Metric(10,96.2,0.1223932373046875), Metric(11,96.35,0.11889525146484375), Metric(12,96.5,0.11355523681640625), Metric(13,96.63,0.10255557861328125), Metric(14,96.67,0.10248739013671875), Metric(15,96.76,0.10121082153320313), Metric(16,97.05,0.09314661254882813), Metric(17,97.09,0.0908234619140625), Metric(18,97.21,0.08782809448242188), Metric(19,97.25,0.084460498046875), Metric(20,97.32,0.08508148803710938), Metric(21,97.49,0.08242890625), Metric(2..."
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : ""
      },
      "output_type" : "execute_result",
      "execution_count" : 21,
      "time" : "Took: 6 minutes 36 seconds 254 milliseconds, at 2017-4-2 23:57"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "15151B8114FC4CB3B94F956AFDDCF06A"
    },
    "cell_type" : "code",
    "source" : "CustomPlotlyChart(history,\n                  layout=\"{title: 'Accuracy on validation set', xaxis: {title: 'epoch'}, yaxis: {title: '%'}}\",\n                  dataOptions=\"{mode: 'lines'}\",\n                  dataSources=\"{x: 'epoch', y: 'acc'}\")",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res29: notebook.front.widgets.charts.CustomPlotlyChart[Seq[Metric]] = <CustomPlotlyChart widget>\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "<div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anon9a1b6e5be7651703df405103341e2339&quot;,&quot;dataInit&quot;:[{&quot;epoch&quot;:1,&quot;acc&quot;:81.94,&quot;loss&quot;:0.57162705078125},{&quot;epoch&quot;:2,&quot;acc&quot;:89.34,&quot;loss&quot;:0.348628173828125},{&quot;epoch&quot;:3,&quot;acc&quot;:91.83,&quot;loss&quot;:0.273960546875},{&quot;epoch&quot;:4,&quot;acc&quot;:92.76,&quot;loss&quot;:0.2305306396484375},{&quot;epoch&quot;:5,&quot;acc&quot;:93.76,&quot;loss&quot;:0.20194395751953126},{&quot;epoch&quot;:6,&quot;acc&quot;:94.87,&quot;loss&quot;:0.17214320068359376},{&quot;epoch&quot;:7,&quot;acc&quot;:95.29,&quot;loss&quot;:0.15777041015625},{&quot;epoch&quot;:8,&quot;acc&quot;:95.75,&quot;loss&quot;:0.1411923583984375},{&quot;epoch&quot;:9,&quot;acc&quot;:95.65,&quot;loss&quot;:0.1371442138671875},{&quot;epoch&quot;:10,&quot;acc&quot;:96.2,&quot;loss&quot;:0.1223932373046875},{&quot;epoch&quot;:11,&quot;acc&quot;:96.35,&quot;loss&quot;:0.11889525146484375},{&quot;epoch&quot;:12,&quot;acc&quot;:96.5,&quot;loss&quot;:0.11355523681640625},{&quot;epoch&quot;:13,&quot;acc&quot;:96.63,&quot;loss&quot;:0.10255557861328125},{&quot;epoch&quot;:14,&quot;acc&quot;:96.67,&quot;loss&quot;:0.10248739013671875},{&quot;epoch&quot;:15,&quot;acc&quot;:96.76,&quot;loss&quot;:0.10121082153320313},{&quot;epoch&quot;:16,&quot;acc&quot;:97.05,&quot;loss&quot;:0.09314661254882813},{&quot;epoch&quot;:17,&quot;acc&quot;:97.09,&quot;loss&quot;:0.0908234619140625},{&quot;epoch&quot;:18,&quot;acc&quot;:97.21,&quot;loss&quot;:0.08782809448242188},{&quot;epoch&quot;:19,&quot;acc&quot;:97.25,&quot;loss&quot;:0.084460498046875},{&quot;epoch&quot;:20,&quot;acc&quot;:97.32,&quot;loss&quot;:0.08508148803710938},{&quot;epoch&quot;:21,&quot;acc&quot;:97.49,&quot;loss&quot;:0.08242890625},{&quot;epoch&quot;:22,&quot;acc&quot;:97.55,&quot;loss&quot;:0.07931015014648438},{&quot;epoch&quot;:23,&quot;acc&quot;:97.6,&quot;loss&quot;:0.07825602416992188},{&quot;epoch&quot;:24,&quot;acc&quot;:97.47,&quot;loss&quot;:0.07847127685546874},{&quot;epoch&quot;:25,&quot;acc&quot;:97.6,&quot;loss&quot;:0.07547276611328126},{&quot;epoch&quot;:26,&quot;acc&quot;:97.64,&quot;loss&quot;:0.074110009765625},{&quot;epoch&quot;:27,&quot;acc&quot;:97.69,&quot;loss&quot;:0.07486264038085938},{&quot;epoch&quot;:28,&quot;acc&quot;:97.73,&quot;loss&quot;:0.07151276245117187},{&quot;epoch&quot;:29,&quot;acc&quot;:97.76,&quot;loss&quot;:0.07469411010742187},{&quot;epoch&quot;:30,&quot;acc&quot;:97.88,&quot;loss&quot;:0.06966272583007813},{&quot;epoch&quot;:31,&quot;acc&quot;:97.84,&quot;loss&quot;:0.066982666015625},{&quot;epoch&quot;:32,&quot;acc&quot;:97.87,&quot;loss&quot;:0.06796741333007812},{&quot;epoch&quot;:33,&quot;acc&quot;:97.95,&quot;loss&quot;:0.06789564208984375},{&quot;epoch&quot;:34,&quot;acc&quot;:98.03,&quot;loss&quot;:0.065538916015625},{&quot;epoch&quot;:35,&quot;acc&quot;:97.88,&quot;loss&quot;:0.066549365234375},{&quot;epoch&quot;:36,&quot;acc&quot;:97.83,&quot;loss&quot;:0.06736263427734375},{&quot;epoch&quot;:37,&quot;acc&quot;:97.98,&quot;loss&quot;:0.0646685302734375},{&quot;epoch&quot;:38,&quot;acc&quot;:97.97,&quot;loss&quot;:0.0628564208984375},{&quot;epoch&quot;:39,&quot;acc&quot;:98.0,&quot;loss&quot;:0.0657330322265625},{&quot;epoch&quot;:40,&quot;acc&quot;:97.98,&quot;loss&quot;:0.063365771484375}],&quot;genId&quot;:&quot;1803379875&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/customPlotlyChart'], \n      function(playground, _magiccustomPlotlyChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magiccustomPlotlyChart,\n    \"o\": {\"js\":\"var layout = {title: 'Accuracy on validation set', xaxis: {title: 'epoch'}, yaxis: {title: '%'}}; var dataSources={x: 'epoch', y: 'acc'}; var dataOptions = {mode: 'lines'}\",\"headers\":[\"epoch\",\"acc\",\"loss\"],\"height\":400}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n      <span class=\"chart-total-item-count\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon82b0c6d0e78ce2ec5afef3b7ba548ea8&quot;,&quot;initialValue&quot;:&quot;40&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId, initialValue)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> entries total</span>\n      <span class=\"chart-sampling-warning\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon618067bd6fdf81ea4eaa83a1fc4c59ea&quot;,&quot;initialValue&quot;:&quot;&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId, initialValue)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n      <div>\n      </div>\n    </div></div>"
      },
      "output_type" : "execute_result",
      "execution_count" : 24,
      "time" : "Took: 1 second 855 milliseconds, at 2017-4-2 23:58"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : false,
      "id" : "66F17A982AF440CFB32F9847471E3A32"
    },
    "cell_type" : "code",
    "source" : "CustomPlotlyChart(history,\n                  layout=\"{title: 'Cross entropy on validation set', xaxis: {title: 'epoch'}, yaxis: {title: 'loss'}}\",\n                  dataOptions=\"\"\"{\n                    mode: 'lines', \n                    line: {\n                          color: 'green',\n                          width: 3\n                          }\n                    }\"\"\",\n                  dataSources=\"{x: 'epoch', y: 'loss'}\")",
    "outputs" : [ {
      "name" : "stdout",
      "output_type" : "stream",
      "text" : "res27: notebook.front.widgets.charts.CustomPlotlyChart[Seq[Metric]] = <CustomPlotlyChart widget>\n"
    }, {
      "metadata" : { },
      "data" : {
        "text/html" : "<div>\n      <script data-this=\"{&quot;dataId&quot;:&quot;anonaeff8599c9be509fecf318df639eb605&quot;,&quot;dataInit&quot;:[{&quot;epoch&quot;:1,&quot;acc&quot;:81.94,&quot;loss&quot;:0.57162705078125},{&quot;epoch&quot;:2,&quot;acc&quot;:89.34,&quot;loss&quot;:0.348628173828125},{&quot;epoch&quot;:3,&quot;acc&quot;:91.83,&quot;loss&quot;:0.273960546875},{&quot;epoch&quot;:4,&quot;acc&quot;:92.76,&quot;loss&quot;:0.2305306396484375},{&quot;epoch&quot;:5,&quot;acc&quot;:93.76,&quot;loss&quot;:0.20194395751953126},{&quot;epoch&quot;:6,&quot;acc&quot;:94.87,&quot;loss&quot;:0.17214320068359376},{&quot;epoch&quot;:7,&quot;acc&quot;:95.29,&quot;loss&quot;:0.15777041015625},{&quot;epoch&quot;:8,&quot;acc&quot;:95.75,&quot;loss&quot;:0.1411923583984375},{&quot;epoch&quot;:9,&quot;acc&quot;:95.65,&quot;loss&quot;:0.1371442138671875},{&quot;epoch&quot;:10,&quot;acc&quot;:96.2,&quot;loss&quot;:0.1223932373046875},{&quot;epoch&quot;:11,&quot;acc&quot;:96.35,&quot;loss&quot;:0.11889525146484375},{&quot;epoch&quot;:12,&quot;acc&quot;:96.5,&quot;loss&quot;:0.11355523681640625},{&quot;epoch&quot;:13,&quot;acc&quot;:96.63,&quot;loss&quot;:0.10255557861328125},{&quot;epoch&quot;:14,&quot;acc&quot;:96.67,&quot;loss&quot;:0.10248739013671875},{&quot;epoch&quot;:15,&quot;acc&quot;:96.76,&quot;loss&quot;:0.10121082153320313},{&quot;epoch&quot;:16,&quot;acc&quot;:97.05,&quot;loss&quot;:0.09314661254882813},{&quot;epoch&quot;:17,&quot;acc&quot;:97.09,&quot;loss&quot;:0.0908234619140625},{&quot;epoch&quot;:18,&quot;acc&quot;:97.21,&quot;loss&quot;:0.08782809448242188},{&quot;epoch&quot;:19,&quot;acc&quot;:97.25,&quot;loss&quot;:0.084460498046875},{&quot;epoch&quot;:20,&quot;acc&quot;:97.32,&quot;loss&quot;:0.08508148803710938},{&quot;epoch&quot;:21,&quot;acc&quot;:97.49,&quot;loss&quot;:0.08242890625},{&quot;epoch&quot;:22,&quot;acc&quot;:97.55,&quot;loss&quot;:0.07931015014648438},{&quot;epoch&quot;:23,&quot;acc&quot;:97.6,&quot;loss&quot;:0.07825602416992188},{&quot;epoch&quot;:24,&quot;acc&quot;:97.47,&quot;loss&quot;:0.07847127685546874},{&quot;epoch&quot;:25,&quot;acc&quot;:97.6,&quot;loss&quot;:0.07547276611328126},{&quot;epoch&quot;:26,&quot;acc&quot;:97.64,&quot;loss&quot;:0.074110009765625},{&quot;epoch&quot;:27,&quot;acc&quot;:97.69,&quot;loss&quot;:0.07486264038085938},{&quot;epoch&quot;:28,&quot;acc&quot;:97.73,&quot;loss&quot;:0.07151276245117187},{&quot;epoch&quot;:29,&quot;acc&quot;:97.76,&quot;loss&quot;:0.07469411010742187},{&quot;epoch&quot;:30,&quot;acc&quot;:97.88,&quot;loss&quot;:0.06966272583007813},{&quot;epoch&quot;:31,&quot;acc&quot;:97.84,&quot;loss&quot;:0.066982666015625},{&quot;epoch&quot;:32,&quot;acc&quot;:97.87,&quot;loss&quot;:0.06796741333007812},{&quot;epoch&quot;:33,&quot;acc&quot;:97.95,&quot;loss&quot;:0.06789564208984375},{&quot;epoch&quot;:34,&quot;acc&quot;:98.03,&quot;loss&quot;:0.065538916015625},{&quot;epoch&quot;:35,&quot;acc&quot;:97.88,&quot;loss&quot;:0.066549365234375},{&quot;epoch&quot;:36,&quot;acc&quot;:97.83,&quot;loss&quot;:0.06736263427734375},{&quot;epoch&quot;:37,&quot;acc&quot;:97.98,&quot;loss&quot;:0.0646685302734375},{&quot;epoch&quot;:38,&quot;acc&quot;:97.97,&quot;loss&quot;:0.0628564208984375},{&quot;epoch&quot;:39,&quot;acc&quot;:98.0,&quot;loss&quot;:0.0657330322265625},{&quot;epoch&quot;:40,&quot;acc&quot;:97.98,&quot;loss&quot;:0.063365771484375}],&quot;genId&quot;:&quot;400670577&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/req(['../javascripts/notebook/playground','../javascripts/notebook/magic/customPlotlyChart'], \n      function(playground, _magiccustomPlotlyChart) {\n        // data ==> data-this (in observable.js's scopedEval) ==> this in JS => { dataId, dataInit, ... }\n        // this ==> scope (in observable.js's scopedEval) ==> this.parentElement ==> div.container below (toHtml)\n\n        playground.call(data,\n                        this\n                        ,\n                        {\n    \"f\": _magiccustomPlotlyChart,\n    \"o\": {\"js\":\"var layout = {title: 'Cross entropy on validation set', xaxis: {title: 'epoch'}, yaxis: {title: 'loss'}}; var dataSources={x: 'epoch', y: 'loss'}; var dataOptions = {\\n                    mode: 'lines', \\n                    line: {\\n                          color: 'green',\\n                          width: 3\\n                          }\\n                    }\",\"headers\":[\"epoch\",\"acc\",\"loss\"],\"height\":400}\n  }\n  \n                        \n                        \n                      );\n      }\n    );/*]]>*/</script>\n    <div>\n      <span class=\"chart-total-item-count\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anond93ba35c528826faca24f9a3521fcdc0&quot;,&quot;initialValue&quot;:&quot;40&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId, initialValue)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p> entries total</span>\n      <span class=\"chart-sampling-warning\"><p data-bind=\"text: value\"><script data-this=\"{&quot;valueId&quot;:&quot;anon840c0904b8927136db83125878ae5034&quot;,&quot;initialValue&quot;:&quot;&quot;}\" type=\"text/x-scoped-javascript\">/*<![CDATA[*/\nreq(\n['observable', 'knockout'],\nfunction (O, ko) {\n  ko.applyBindings({\n      value: O.makeObservable(valueId, initialValue)\n    },\n    this\n  );\n});\n        /*]]>*/</script></p></span>\n      <div>\n      </div>\n    </div></div>"
      },
      "output_type" : "execute_result",
      "execution_count" : 23,
      "time" : "Took: 2 seconds 413 milliseconds, at 2017-4-2 23:58"
    } ]
  }, {
    "metadata" : {
      "trusted" : true,
      "input_collapsed" : false,
      "collapsed" : true,
      "id" : "AF310E51E16F4F378B1482A1E5060F86"
    },
    "cell_type" : "code",
    "source" : "",
    "outputs" : [ ]
  } ],
  "nbformat" : 4
}